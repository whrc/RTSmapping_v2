---
title: "Inference Domain and Subregions"
format: html
author: "Heidi Rodenhizer"
---

This document derives the inference domain for RTSMapping_v2 based on the ArcticDEM v4 Mosaic and availability of different imagery sources (PlanetScope Global Quarterly Visual Basemaps and Sentinel-2).

# Set Up

```{r}
library(sf)
library(terra)
library(tidyterra)
library(tidyverse)
library(ggnewscale)
library(viridis)
```

```{r}
theme_set(theme_bw())
```

# Define Functions
A bunch of the tiles near the horizontal origin of the CRS are missing a chunk between -180 m and 180 m. The following two functions are used to manually fix this problem.
All of the tiles are built to be 50 x 50 km with an extra 100 m buffer on either side, except the problem ones.
These functions identify problematic tiles as tiles with two multipolygon components (`length(geometry[[1]]) == 2`). For tiles that are on the left side of the origin (`column == 2`), the first polygon component is the bulk of the tile with a few incorrect values. For tiles on the right side of the origin, it is the opposite. These functions remove the incorrect component of each multipolygon and replaces the incorrect values in the correct component.

## replace_incorrect_values
```{r}
replace_incorrect_values = function(x) {
  case_when(
    x == 180 ~ -100,
    x == -180 ~ 100,
    TRUE ~ x
  )
}
```

## fix_geometry_at_origin
```{r}
fix_geometry_at_origin = function(geometry, side) {
  # Extract correct component of multipolygon, if it has two components
  if (length(geometry[[1]]) == 2) {
    # print(geometry[[1]])
    if (side == 1) {
      geometry[[1]][[1]] <- NULL # If column == 1 (left side of origin), keep second multipolygon component
    } else if (side == 2) {
      geometry[[1]][[2]] <- NULL # If column == 2 (right side of origin), keep first multipolygon component
    }
    # print(geometry[[1]])

    # Replace incorrect values
    new_values = geometry[[1]][[1]][[1]][, 1]
    new_values = replace_incorrect_values(new_values)
    geometry[[1]][[1]][[1]][, 1] = new_values
  }

  return(geometry)
}
```

## round_coordinates
```{r}
round_coordinates = function(sfc, n) {
  coords = st_coordinates(sfc) |>
    round(n)
  coords = coords[, 1:2]
  coords = coords |>
    list() |>
    st_polygon() |>
    st_sfc(crs = st_crs(sfc))
  # st_set_geometry(sfc, coords)
  return(coords)
}
```

## any_ones

```{r}
any_ones = function(values) {
  case_when(
    any(values == 1, na.rm = TRUE) ~ 1,
    TRUE ~ NA
  )
}
```

# Import Data
## Domain
```{r}
# ArcticDEM
arctic_dem = st_read(
  "./domain/data/ArcticDEM_Mosaic_Index_latest_shp/ArcticDEM_Mosaic_Index_v4_1_2m.shp"
) |>
  separate_wider_delim(
    tile,
    delim = "_",
    names = c("superrow", "supercolumn", "row", "column"),
    cols_remove = FALSE
  ) |>
  mutate(across(superrow:column, ~ as.numeric(.x))) |>
  rowwise() |>
  mutate(geometry = fix_geometry_at_origin(geometry, column)) |>
  ungroup() |>
  st_as_sf()

# # Planet Grids
# planet_grids = st_read(
#   "./domain/data/arctic_boreal_planet_basemap_grids.geojson"
# ) |>
#   st_make_valid() |>
#   rowwise() |>
#   mutate(geometry = round_coordinates(geometry, 5)) |>
#   ungroup()

# Planet Domain (derived from Planet Grids)
planet_domain = st_read("./domain/data/circumpolar_planet_domain.geojson") |>
  st_transform(crs = st_crs(arctic_dem))
arctic_boreal = st_read(
  "./domain/data/tundra_and_boreal/tundra_and_boreal.shp"
) |>
  st_transform(crs = st_crs(arctic_dem)) |>
  st_union() |>
  st_as_sf()

# Permafrost Zone
template = rast(
  xmin = -5000000,
  xmax = 5000000,
  ymin = -5000000,
  ymax = 5000000,
  crs = "EPSG:3413",
  resolution = 1000
)
perm_prob = rast("./domain/data/NIEER_Probability.tif") |>
  project(template)
```

## Subregions
Ecoregions from Dinerstein et al. 2017 will be used as the starting point for our subregions.

```{r}
ecoregions = st_read("./domain/data/Ecoregions2017/Ecoregions2017.shp") |>
  st_transform(crs = st_crs(arctic_dem)) |>
  mutate(
    across(
      c(-geometry),
      ~ case_when(
        .x == "N/A" ~ NA,
        TRUE ~ .x
      )
    )
  )

training_polys = st_read(
  "./domain/data/planet_perfect_polygons_union_result.geojson"
) |>
  st_transform(st_crs(arctic_dem))
```

# Domain
## Dissolve Internal Boundaries
### ArcticDEM
```{r}
arcdem_domain = arctic_dem |>
  summarise(geometry = st_union(geometry))
```

```{r}
ggplot() +
  geom_sf(
    data = arcdem_domain,
    fill = "transparent",
    linewidth = 0.5
  )
```

### Planet Grids
```{r}
# planet_domain = planet_grids |>
#   summarise(geometry = st_union(geometry)) # |>

# st_write(
#   planet_domain,
#   './domain/data/circumpolar_planet_domain.geojson'
# )
```

```{r}
ggplot() +
  geom_sf(
    data = arcdem_domain,
    aes(color = "ArcticDEM"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = planet_domain,
    aes(color = "Planet"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  scale_color_manual(values = c("darkgoldenrod1", "cyan4"))
```

## Prepare Permafrost Extent Map
The permafrost probability map is highly spotty. We are including any areas that have some coverage of permafrost within a 100 x 100 km pixel.

```{r}
perm_prob[perm_prob > 0] = 1
perm_prob[is.na(perm_prob)] = 0
perm_prob_sf = perm_prob |>
  crop(arctic_boreal) |>
  mask(arctic_boreal) |>
  aggregate(
    fact = 100,
    fun = any_ones
  ) |> # Check if there is any probability of permafrost within 100 km
  as.polygons() |>
  st_as_sf()
perm_prob[perm_prob == 0] = NA
```

```{r}
ggplot() +
  geom_spatraster(data = perm_prob) +
  scale_fill_continuous(na.value = "transparent") +
  geom_sf(
    data = perm_prob_sf,
    fill = "transparent"
  ) +
  coord_sf(expand = FALSE)
```

## Circumpolar
We started with the Arctic Boreal region that Anna V made to create our circumpolar region. This region is limited by the extent of the ArcticDEM, because we need data from the ArcticDEM, and by the permafrost zone, because permafrost is a necessary precursor for RTS. Because our confidence in permafrost maps is low, so it may make sense to buffer use a more inclusive approach. 

```{r}
circumpolar = arctic_boreal |>
  st_intersection(arcdem_domain) |>
  st_intersection(perm_prob_sf)
```

```{r}
ggplot() +
  geom_sf(
    data = arcdem_domain,
    aes(color = "ArcticDEM"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = arctic_boreal,
    aes(color = "Arctic/Boreal"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = circumpolar,
    aes(color = "Circumpolar"),
    fill = "transparent",
    linewidth = 1
  ) +
  scale_color_manual(values = c("cyan4", "darkgoldenrod1", "black")) +
  theme(legend.title = element_blank())
```

```{r}
# st_write(
#   circumpolar,
#   "./domain/circumpolar_domain.geojson"
# )
```

## Circumpolar South
This is the portion of the ArcticDEM for which we have Planet imagery.

```{r}
circumpolar_south = circumpolar |>
  st_intersection(planet_domain)
```

```{r}
ggplot() +
  geom_sf(
    data = circumpolar,
    aes(color = "Circumpolar"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = circumpolar_south,
    aes(color = "Circumpolar South"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  scale_color_manual(values = c("black", "cyan4")) +
  theme(legend.title = element_blank())
```

```{r}
# st_write(
#   circumpolar_south,
#   "./domain/circumpolar_south_domain.geojson"
# )
```

## Circumpolar North
This is the portion of the Circumpolar region for which we do not have Planet data.

```{r}
circumpolar_north = circumpolar |>
  st_difference(planet_domain)
```

```{r}
ggplot() +
  geom_sf(
    data = circumpolar,
    aes(color = "Circumpolar"),
    fill = "transparent",
    linewidth = 1
  ) +
  geom_sf(
    data = circumpolar_south,
    aes(color = "Circumpolar South"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = circumpolar_north,
    aes(color = "Circumpolar North"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  scale_color_manual(values = c("black", "cyan4", "darkgoldenrod1")) +
  theme(legend.title = element_blank())
```

```{r}
# st_write(
#   circumpolar_north,
#   "./domain/circumpolar_north_domain.geojson"
# )
```

# Subregions
## Clip to Domain
The ecoregions need to be clipped to the circumpolar region.

```{r}
subregions = ecoregions |>
  filter(BIOME_NAME %in% c("Tundra", "Boreal Forests/Taiga")) |>
  st_intersection(circumpolar) |>
  st_as_sf() |>
  select(ECO_NAME, COLOR) |>
  arrange(ECO_NAME)
```

```{r}
ggplot() +
  geom_sf(
    data = subregions,
    aes(color = ECO_NAME, fill = ECO_NAME)
  ) +
  scale_color_manual(values = subregions$COLOR) +
  scale_fill_manual(values = subregions$COLOR) +
  new_scale_color() +
  geom_sf(
    data = circumpolar,
    aes(color = "Circumpolar"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  scale_color_manual(values = c("black")) +
  theme(
    legend.position = "bottom",
    legend.title = element_blank()
  )
```

```{r}
# st_write(
#   subregions,
#   "./domain/circumpolar_subregions.geojson"
# )
```

## Check Training Polygon Counts by Subregion
```{r}
training_polys_regions = training_polys |>
  st_join(
    subregions |>
      select(RegionName = ECO_NAME),
    join = st_nearest_feature
  )
```

```{r}
region_poly_count = training_polys_regions |>
  st_drop_geometry() |>
  summarise(
    RTSCount = n(),
    .by = RegionName
  ) |>
  mutate(
    RTSPercent = RTSCount / sum(RTSCount)
  )
```

```{r}
ggplot(
  region_poly_count,
  aes(x = RegionName, y = RTSCount)
) +
  geom_col() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```

```{r}
ggplot(
  region_poly_count,
  aes(x = RegionName, y = RTSPercent)
) +
  geom_col() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```

```{r}
small_clusters_percent = region_poly_count |>
  filter(RTSPercent < 0.1) |>
  summarise(TotalPercentSmallClusters = sum(RTSPercent))
```