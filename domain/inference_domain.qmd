---
title: "Inference Domain and Subregions"
format: html
author: "Heidi Rodenhizer"
---

This document describes the process of creating the inference domain over which RTS will be mapped in RTSMapping_v2. This domain is based on the intersection between the Arctic boreal region, the permafrost region, and the ArcticDEM v4 Mosaic. Additionally, it was split into a northern and southern domain based on the extent of PlanetScope Global Quarterly Visual Basemaps which are only guaranteed to 74 degrees N (but actually extend to approximately 76 degrees N in most cases).

::: {.content-hidden}
# Set Up

```{r}
#| include: false

library(sf)
library(terra)
library(tidyterra)
library(tidyverse)
library(ggnewscale)
library(viridis)
```

```{r}
#| include: false

theme_set(theme_bw())
```

# Define Functions

## For ArcticDEM Data Issues
A bunch of the ArcticDEM tiles near the horizontal origin of the CRS are missing a chunk between -180 m and 180 m. The following two functions are used to manually fix this problem.
All of the tiles are built to be 50 x 50 km with an extra 100 m buffer on either side, except the problem ones.
These functions identify problematic tiles as tiles with two multipolygon components (`length(geometry[[1]]) == 2`). For tiles that are on the left side of the origin (`column == 2`), the first polygon component is the bulk of the tile with a few incorrect values. For tiles on the right side of the origin, it is the opposite. These functions remove the incorrect component of each multipolygon and replaces the incorrect values in the correct component.

### replace_incorrect_values
```{r}
replace_incorrect_values = function(x) {
  case_when(
    x == 180 ~ -100,
    x == -180 ~ 100,
    TRUE ~ x
  )
}
```

### fix_geometry_at_origin
```{r}
fix_geometry_at_origin = function(geometry, side) {
  # Extract correct component of multipolygon, if it has two components
  if (length(geometry[[1]]) == 2) {
    # print(geometry[[1]])
    if (side == 1) {
      geometry[[1]][[1]] <- NULL # If column == 1 (left side of origin), keep second multipolygon component
    } else if (side == 2) {
      geometry[[1]][[2]] <- NULL # If column == 2 (right side of origin), keep first multipolygon component
    }
    # print(geometry[[1]])

    # Replace incorrect values
    new_values = geometry[[1]][[1]][[1]][, 1]
    new_values = replace_incorrect_values(new_values)
    geometry[[1]][[1]][[1]][, 1] = new_values
  }

  return(geometry)
}
```

## For Read Errors in Planet Grids
### round_coordinates
There appears to be a rounding issue when the Planet Grids are read in, where some of the tiles end up with slightly different corners than the adjacent tiles. This function allows all coordinates in the Planet Grids file to be rounded to 5 decimal places to fix the problem.
```{r}
round_coordinates = function(sfc, n) {
  coords = st_coordinates(sfc) |>
    round(n)
  coords = coords[, 1:2]
  coords = coords |>
    list() |>
    st_polygon() |>
    st_sfc(crs = st_crs(sfc))
  # st_set_geometry(sfc, coords)
  return(coords)
}
```

## For Deriving the Permafrost Zone Map
### any_ones
This function is used to find any pixels with a value of 1, and is used to find any 100 km x 100 km areas that contain some likelihood of permafrost within at least one pixel.
```{r}
any_ones = function(values) {
  case_when(
    any(values == 1, na.rm = TRUE) ~ 1,
    TRUE ~ NA
  )
}
```

:::

# Import Data
## Domain
```{r}
#| output: false

# ArcticDEM
arctic_dem = st_read(
  "./domain/data/ArcticDEM_Mosaic_Index_latest_shp/ArcticDEM_Mosaic_Index_v4_1_2m.shp"
) |>
  separate_wider_delim(
    tile,
    delim = "_",
    names = c("superrow", "supercolumn", "row", "column"),
    cols_remove = FALSE
  ) |>
  mutate(across(superrow:column, ~ as.numeric(.x))) |>
  rowwise() |>
  mutate(geometry = fix_geometry_at_origin(geometry, column)) |>
  ungroup() |>
  st_as_sf()

# # Planet Grids
# planet_grids = st_read(
#   "./domain/data/arctic_boreal_planet_basemap_grids.geojson"
# ) |>
#   st_make_valid() |>
#   rowwise() |>
#   mutate(geometry = round_coordinates(geometry, 5)) |>
#   ungroup()

# Planet Domain (derived from Planet Grids)
planet_domain = st_read("./domain/data/circumpolar_planet_domain.geojson") |>
  st_transform(crs = st_crs(arctic_dem))
arctic_boreal = st_read(
  "./domain/data/tundra_and_boreal/tundra_and_boreal.shp"
) |>
  st_transform(crs = st_crs(arctic_dem)) |>
  st_union() |>
  st_as_sf()

# Permafrost Probability
template = rast(
  xmin = -5000000,
  xmax = 5000000,
  ymin = -5000000,
  ymax = 5000000,
  crs = "EPSG:3413",
  resolution = 1000
)
perm_prob = rast("./domain/data/NIEER_Probability.tif") |>
  project(template)
```

## Subregions
Ecoregions from Dinerstein et al. 2017 will be used as the starting point for our subregions.

```{r}
#| output: false

ecoregions = st_read("./domain/data/Ecoregions2017/Ecoregions2017.shp") |>
  st_transform(crs = st_crs(arctic_dem)) |>
  mutate(
    across(
      c(-geometry),
      ~ case_when(
        .x == "N/A" ~ NA,
        TRUE ~ .x
      )
    )
  )

training_polys = st_read(
  "./domain/data/planet_perfect_polygons_union_result.geojson"
) |>
  st_transform(st_crs(arctic_dem))
```

# Domain
## Dissolve Internal Boundaries
### ArcticDEM
```{r}
arcdem_domain = arctic_dem |>
  summarise(geometry = st_union(geometry))
```

```{r}
#| echo: false

ggplot() +
  geom_sf(
    data = arcdem_domain,
    fill = "transparent",
    linewidth = 0.5
  )
```

### Planet Grids
```{r}
# planet_domain = planet_grids |>
#   summarise(geometry = st_union(geometry)) # |>
```

```{r}
#| include: false

# st_write(
#   planet_domain,
#   './domain/data/circumpolar_planet_domain.geojson'
# )
```

```{r}
#| echo: false

ggplot() +
  geom_sf(
    data = arcdem_domain,
    aes(color = "ArcticDEM"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = planet_domain,
    aes(color = "Planet"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  scale_color_manual(values = c("darkgoldenrod1", "cyan4"))
```

## Prepare Permafrost Extent Map
The permafrost probability map is highly spotty. We are including any areas that fall within the Arctic boreal region and have some coverage of permafrost within a 100 x 100 km pixel.

```{r}
perm_prob[perm_prob > 0] = 1
perm_prob[is.na(perm_prob)] = 0
perm_prob_sf = perm_prob |>
  crop(arctic_boreal) |>
  mask(arctic_boreal) |>
  aggregate(
    fact = 100,
    fun = any_ones
  ) |> # Check if there is any probability of permafrost within 100 km
  as.polygons() |>
  st_as_sf()
perm_prob[perm_prob == 0] = NA
```

```{r}
#| echo: false

ggplot() +
  geom_spatraster(data = perm_prob) +
  scale_fill_continuous(na.value = "transparent") +
  geom_sf(
    data = perm_prob_sf,
    fill = "transparent",
    linewidth = 0.5
  ) +
  coord_sf(expand = FALSE)
```

## Circumpolar Domain
We started with the Arctic Boreal region that Anna V made to create our circumpolar region. This region is first reduced by taking the intersection with the ArcticDEM, because we need data from the ArcticDEM. It is further reduced by taking the intersection with the permafrost zone, because permafrost is a necessary precursor for RTS.

```{r}
circumpolar = arctic_boreal |>
  st_intersection(arcdem_domain) |>
  st_intersection(perm_prob_sf)
```

```{r}
#| echo: false

ggplot() +
  geom_sf(
    data = arcdem_domain,
    aes(color = "ArcticDEM"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = arctic_boreal,
    aes(color = "Arctic/Boreal"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = circumpolar,
    aes(color = "Circumpolar"),
    fill = "transparent",
    linewidth = 1
  ) +
  scale_color_manual(values = c("cyan4", "darkgoldenrod1", "black")) +
  theme(legend.title = element_blank())
```

```{r}
#| include: false

# st_write(
#   circumpolar,
#   "./domain/circumpolar_domain.geojson"
# )
```

## Circumpolar South Domain
This is the portion of the ArcticDEM for which we have Planet imagery.

```{r}
circumpolar_south = circumpolar |>
  st_intersection(planet_domain)
```

```{r}
#| echo: false

ggplot() +
  geom_sf(
    data = circumpolar,
    aes(color = "Circumpolar"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = circumpolar_south,
    aes(color = "Circumpolar South"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  scale_color_manual(values = c("black", "cyan4")) +
  theme(legend.title = element_blank())
```

```{r}
#| include: false

# st_write(
#   circumpolar_south,
#   "./domain/circumpolar_south_domain.geojson"
# )
```

## Circumpolar North Domain
This is the portion of the Circumpolar region for which we do not have Planet data.

```{r}
circumpolar_north = circumpolar |>
  st_difference(planet_domain)
```

```{r}
#| echo: false

ggplot() +
  geom_sf(
    data = circumpolar,
    aes(color = "Circumpolar"),
    fill = "transparent",
    linewidth = 1
  ) +
  geom_sf(
    data = circumpolar_south,
    aes(color = "Circumpolar South"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  geom_sf(
    data = circumpolar_north,
    aes(color = "Circumpolar North"),
    fill = "transparent",
    linewidth = 0.5
  ) +
  scale_color_manual(values = c("black", "darkgoldenrod1", "cyan4")) +
  theme(legend.title = element_blank())
```

```{r}
#| include: false

# st_write(
#   circumpolar_north,
#   "./domain/circumpolar_north_domain.geojson"
# )
```

# Subregions
## Clip to Domain
The ecoregions from Dinerstein et al. 2017 need to be clipped to the circumpolar region created above.

```{r}
subregions = ecoregions |>
  filter(BIOME_NAME %in% c("Tundra", "Boreal Forests/Taiga")) |>
  st_intersection(circumpolar) |>
  st_as_sf() |>
  select(ECO_NAME, COLOR) |>
  arrange(ECO_NAME)
```

```{r}
#| echo: false
#| fig-width: 9.5
#| fig-height: 15

ggplot() +
  geom_sf(
    data = subregions,
    aes(color = ECO_NAME, fill = ECO_NAME)
  ) +
  scale_color_manual(
    values = subregions$COLOR,
    guide = guide_legend(ncol = 3)
  ) +
  scale_fill_manual(
    values = subregions$COLOR,
    guide = guide_legend(ncol = 3)
  ) +
  new_scale_color() +
  geom_sf(
    data = circumpolar,
    color = "black",
    fill = "transparent",
    linewidth = 0.5
  ) +
  theme(
    legend.position = "bottom",
    legend.title = element_blank()
  )
```

```{r}
#| include: false

# st_write(
#   subregions,
#   "./domain/circumpolar_subregions.geojson"
# )
```

## Check Training Polygon Counts by Subregion
```{r}
region_poly_count = training_polys |>
  st_join(
    subregions |>
      select(RegionName = ECO_NAME),
    join = st_nearest_feature
  ) |>
  st_drop_geometry() |>
  summarise(
    RTSCount = n(),
    .by = RegionName
  ) |>
  mutate(
    RTSPercent = RTSCount / sum(RTSCount)
  )
```

```{r}
#| echo: false

ggplot(
  region_poly_count,
  aes(x = RegionName, y = RTSCount)
) +
  geom_col() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```

```{r}
#| echo: false

ggplot(
  region_poly_count,
  aes(x = RegionName, y = RTSPercent)
) +
  geom_col() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```

```{r}
small_clusters_percent = region_poly_count |>
  filter(RTSPercent < 0.1) |>
  summarise(TotalPercentSmallClusters = sum(RTSPercent))
small_clusters_percent
```