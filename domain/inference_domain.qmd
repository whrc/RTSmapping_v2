---
title: "Inference Domain"
format: html
author: "Heidi Rodenhizer"
---

This document derives the inference domain for RTSMapping_v2 based on the ArcticDEM v4 Mosaic and availability of different imagery sources (PlanetScope Global Quarterly Visual Basemaps and Sentinel-2).

# Load Libraries

```{r}
library(sf)
library(tidyverse)
```

# Define Functions

```{r}

```

# Import Data

```{r}
arctic_dem = st_read(
  "./domain/data/ArcticDEM_Mosaic_Index_latest_shp/ArcticDEM_Mosaic_Index_v4_1_2m.shp"
) |>
  separate_wider_delim(
    tile,
    delim = "_",
    names = c("superrow", "supercolumn", "row", "column"),
    cols_remove = FALSE
  ) |>
  mutate(across(superrow:column, ~ as.numeric(.x))) |>
  rowwise() |>
  mutate(geometry_length = length(geometry[[1]])) |>
  ungroup() |>
  st_as_sf()
planet_grids = st_read("./domain/data/circumpolar_global_basemap_grids.geojson")
```

# Dissolve Internal Boundaries

```{r}
arctic_domain = arctic_dem |>
  summarise(geometry = st_union(geometry))
```


ArticDEM cells along horizontal origin are missing a small sliver between -180 and 100... why? How can I fix?
```{r}
ggplot() +
  geom_sf(
    data = arctic_dem |>
      filter(
        (supercolumn == 40 & column == 2) | (supercolumn == 41 & column == 1)
      ),
    aes(color = column),
    fill = "transparent"
  ) +
  geom_sf(
    data = arctic_domain,
    fill = "transparent",
    linewidth = 1
  ) +
  coord_sf(
    xlim = c(-100000, 100000),
    ylim = c(1200000, 3500000)
  )
```


```{r}
problem_tiles = arctic_dem |>
  filter(
    (supercolumn == 40 & column == 2) | (supercolumn == 41 & column == 1)
  )
example_ok_tiles_left = arctic_dem |>
  filter((supercolumn == 40 & column == 1))
example_ok_tiles_right = arctic_dem |>
  filter((supercolumn == 41 & column == 2))
problem_tiles_subset = problem_tiles |>
  filter(superrow == 19)
```

```{r}
ggplot() +
  geom_sf(
    data = problem_tiles_subset,
    aes(color = tile),
    fill = "transparent",
    linewidth = 1
  )
```

If column == 1, we want to keep geometry[[2]] and if column == 2, we want to keep geometry[[1]].
Extract X values.
If all negative, replace -180 with 100. If all positive, replace 180 with -100.

```{r}
example_fix_1 = problem_tiles_subset |> slice(2) |> st_geometry()
example_fix_2 = problem_tiles_subset |> slice(3) |> st_geometry()

replace_incorrect_values = function(x) {
  case_when(
    x == 180 ~ -100,
    x == -180 ~ 100,
    TRUE ~ x
  )
}

fix_geometry_at_origin = function(geometry, side) {
  # Extract correct component of multipolygon
  new_geometry = geometry
  # print(new_geometry[[1]])
  if (side == 1) {
    new_geometry[[1]][[1]] <- NULL # If column == 1 (left side of origin), keep second multipolygon component
  } else if (side == 2) {
    new_geometry[[1]][[2]] <- NULL # If column == 2 (right side of origin), keep first multipolygon component
  }
  # print(new_geometry[[1]])

  # Replace incorrect values
  new_values = new_geometry[[1]][[1]][[1]][, 1]
  new_values = replace_incorrect_values(new_values)
  new_geometry[[1]][[1]][[1]][, 1] = new_values

  return(new_geometry)
}

fix_geometry_at_origin(example_fix_1, side = 2)[[1]]
fix_geometry_at_origin(example_fix_2, side = 1)[[1]]

problem_tiles_subset_fix = problem_tiles_subset |>
  rowwise() |>
  mutate(geometry = fix_geometry_at_origin(geometry, column)) |>
  ungroup()
```

```{r}
ggplot() +
  geom_sf(
    data = problem_tiles_subset_fix,
    aes(color = tile),
    fill = "transparent",
    linewidth = 1
  )
```

# Circumpolar

# Circumpolar South

# Circumpolar North
